> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/EsvWbkNTw5IhKmOPtCYZsA)

感谢 AI，让我等菜鸡也能分析 vmp 了。  
使用 AI，让你可以和全球最顶尖的人一起工作。

对 vmp 的分析，我以为难点有两个：  
1、对取指、译指、指令分发的流程的整体把握；  
2、对 vmp 内部的虚拟寄存器、虚拟内存的结构了解；

而对于 hanler 的翻译，我认为在了解上面两个难点之后，就是体力活了，但是从理解 hanler 到还原算法还是有段路要走的。

简单粗暴，直接让 ai 分析vm函数，下面是给出的回答，看起来还不错

```
`这是一个 虚拟机字节码解释器（VM Interpreter），证据如下：  
1. 指令获取和解码循环  
while (2) {  
    v11 = *result;  // 从指令指针读取32位指令  
    // 解码指令的各个字段  
    v12 = v11 & 0x10000000;  // 位28  
    v13 = v11 & 0x20000000;  // 位29  
    v14 = v11 & 0x40000000;  // 位30  
    v15 = (v11 >> 11) & 0x1F;  // 目标寄存器  
    v16 = (v11 >> 21) & 0x1F;  // 源寄存器1  
    v17 = HIWORD(v11) & 0x1F;  // 源寄存器2  
    v18 = v11 & 0x80000000;   // 位31  
      
    switch (v11 & 0x3F) {  // 根据低6位opcode跳转  
        // 64种不同的操作码  
    }  
}  
  
2. 虚拟寄存器数组  
v7 (X21寄存器指向的数组) 是虚拟寄存器文件  
代码中频繁访问 v7[(unsigned int)v16 + 1] 这样的模式  
至少有32个虚拟寄存器（从位字段提取0-31）  
...`
```

下面开始整个流程的分析：

**一、取指、译指的过程分析**

1.  1. 主循环入口和取指 (Instruction Fetch)
    

```
`loc_2CC4:  
    LDUR    X1, [X19,#-0x20]        ; 加载VM状态标志到X1  
  
loc_2CC8:  ← 主循环开始  
    CMP     X1, [#2](javascript:;)                  ; 检查VM状态是否为2  
    B.EQ    loc_3FBC                ; 如果是，跳转到特殊处理  
    LDR     W12, [X0]               ; ★ 取指：从X0（指令指针）读取32位指令到W12`
```

1.  2. 指令解码 (Instruction Decode)
    

```
`loc_2CD4:  
    AND     W10, W12, [#0x3F](javascript:;)         ; ★ 提取opcode（指令的低6位）  
    CMP     W10, [#0x3F](javascript:;)              ; 检查opcode是否 > 63  
    B.HI    def_2D3C                ; 越界则跳转到默认处理  
  
    ; === 解码指令字段 ===  
    LDRSW   X3, [X27,X10,LSL[#2](javascript:;)]     ; ★ 从跳转表读取偏移  
                                    ; X27 = 跳转表基址  
                                    ; X10 = opcode (0-63)  
                                    ; LSL[#2](javascript:;) = 乘以4（每个表项4字节）  
    LSR     W11, W12, [#0xB](javascript:;)          ; 右移11位，准备提取字段  
    AND     W14, W11, [#2](javascript:;)            ; 提取位12  
      
      
    ; === 提取各个指令字段 ===  
    AND     W16, W12, [#0x10000000](javascript:;)   ; 提取位28  
    AND     W2, W11, [#4](javascript:;)             ; 提取位13  
    BFXIL   W14, W12, [#0x1F](javascript:;), [#1](javascript:;)     ; 从 W12 的位31提取1位，插入到 W14 的低位  
    ORR     W14, W14, W2            ;   
    AND     W2, W11, [#8](javascript:;)             ; 提取位14  
    AND     W10, W11, [#0x10](javascript:;)         ; 提取位15  
    LSR     W11, W16, [#0x1A](javascript:;)         ; 右移26位  
    AND     W15, W12, [#0x20000000](javascript:;)   ; 提取位29  
    ORR     W2, W14, W2             ;   
    BFXIL   W11, W12, [#0x1A](javascript:;), [#2](javascript:;)     ; 提取位26-27  
    AND     W14, W12, [#0x40000000](javascript:;)   ; 提取位30  
    ORR     W10, W2, W10            ; W10 = 目标寄存器编号    
    ORR     W11, W11, W15,LSR[#26](javascript:;)    ; W11 = 立即数字段        
    ADD     X2, X3, X27             ; X2 = 跳转表基址 + 偏移  
      
    ; === 提取源操作数寄存器 ===  
    UBFX    W9, W12, [#0x15](javascript:;), [#5](javascript:;)      ; 提取位21-25 → 源寄存器1  
    UBFX    W8, W12, [#0x10](javascript:;), [#5](javascript:;)      ; 提取位16-20 → 源寄存器2  
      
    AND     W13, W12, [#0x80000000](javascript:;)   ; 提取位31（符号位）  
    AND     W18, W12, [#0x4000000](javascript:;)    ; 提取位26  
    AND     W17, W12, [#0x8000000](javascript:;)    ; 提取位27  
    ORR     W11, W11, W14,LSR[#26](javascript:;)    ; 组合立即数高位  
指令格式解析：  
  
31 30 29 28 27 26 25-21 20-16 15-11 10-6  5-0  
│  │  │  │  │  │   │     │     │     │    │  
符 │  │  │  │  │   Rs1   Rs2   Rd   字段 opcode  
号 │  │  │  │  └─ 立即数/字段  
位 └──┴──┴──┴───── 立即数/标志位` 
```

1.  3. 指令分发 (Dispatch)
    

```
`loc_2D3C:  
    BR      X2                      ; ★ 间接跳转到指令处理代码  
                                    ; X2 = 跳转表基址 + 偏移  
跳转表结构：  
  
jpt_2D3C:  
    .dword  loc_2D40 - jpt_2D3C     ; case 0: 偏移量  
    .dword  def_2D3C - jpt_2D3C     ; case 1: 默认处理  
    .dword  loc_305C - jpt_2D3C     ; case 2: 比较指令  
    .dword  loc_38F8 - jpt_2D3C     ; case 3: 逻辑运算  
    ...                              ; 总共64个case`
```

4、具体指令执行示例（略，后面分析）

5、指令完成与PC更新

```
`def_2D3C:  ; 指令执行完成的共同出口  
    LDR     X9, [X21]               ; 读取虚拟PC  
    LDUR    X8, [X19,#-0x20]        ; 读取VM状态  
    ADD     X0, X9, [#4](javascript:;)              ; ★ PC += 4 (下一条指令)  
    CMP     X8, [#2](javascript:;)                  ; 检查状态  
    STR     X0, [X21]               ; 更新虚拟PC  
    B.EQ    loc_3AA8                ; 状态检查  
      
    ; ...状态检查逻辑...  
      
    CBNZ    X0, loc_2CC4            ; ★ 如果PC非空，继续循环  
                                    ; 返回loc_2CC4取下一条指令`
```

整体流程总结

```
`1. 取指 [0x2CC8]   
   ↓  
2. 解码 [0x2CD4-0x2D38]  
   - 提取opcode (bit 5:0)  
   - 提取操作数 (bit 31:6)  
   ↓  
3. 一级分发 [0x2D3C]  
   - 查跳转表 jpt_2D3C[opcode]  
   ↓  
4. 二级分发 [某些case]  
   - 根据次级opcode再次分发  
   ↓  
5. 执行Handler  
   - 访问VM寄存器堆 [X21+offset]  
   - 执行运算  
   - 写回结果  
   ↓  
6. PC更新 [0x3A78]  
   - PC += 4 或 跳转  
   ↓  
7. 循环 [0x2CC4] 或 退出`
```

**二、 vm 的关键数据结构分析**

1、虚拟寄存器模拟

```
`  
VM上下文结构 (基于 X19 = 栈帧指针):  
  
[X19 - 0x138] = X21 → 虚拟寄存器堆起始地址  
├─ [X21 + 0x00] : 寄存器堆头部（可能是元数据）  
├─ [X21 + 0x08] : R0  (虚拟寄存器0)  ← v7[0+1]  
├─ [X21 + 0x10] : R1  (虚拟寄存器1)  ← v7[1+1]  
├─ [X21 + 0x18] : R2  (虚拟寄存器2)  
├─ ...  
└─ [X21 + 0xF8] : R31 (虚拟寄存器31)  
  
;虚拟寄存器空间在真实内存中分配  
0x2C34: LDP X20, X19, [X4]         ; 从VM上下文加载  
0x2C48: SUB X21, X19, [#0x138](javascript:;)       ; X21 = 寄存器堆基址 (0x138 = 312)  
  
; 读取虚拟寄存器 rs1 (索引在W9)  
0x3BD8: ADD X11, X21, [#8](javascript:;)           ; X11 = 寄存器堆基址 + 8  
0x3BDC: LDR X9, [X11, W9, UXTW[#3](javascript:;)]  ; X9 = R[rs1]  
  
; 写入虚拟寄存器 rd (索引在W10)  
0x3BE4: STR X8, [X11, W10, UXTW[#3](javascript:;)] ; R[rd] = X8`
```

2、虚拟机内部内存实现

```
`VM上下文完整布局 (基于 X19):  
  
高地址  
│  
├─ [X19 - 0x08]  : 指令段基址指针 (code_base)  
├─ [X19 - 0x10]  : 返回地址 (return_pc)  
├─ [X19 - 0x18]  : 跳转目标地址  
├─ [X19 - 0x20]  : VM状态标志  
│                  0 = 正常执行  
│                  1 = 条件跳转成功  
│                  2 = 即将调用外部函数  
│                  3 = 从外部函数返回  
│  
├─ [X19 - 0x28]  : HI 寄存器 (高位乘法结果)  
├─ [X19 - 0x30]  : LO 寄存器 (低位乘法结果)  
│  
├─ [X19 - 0x48]  : 临时对齐缓冲区指针  
├─ [X19 - 0x100] : 参数寄存器保存区  
│   ├─ [X19 - 0x110] : arg1 (X1)  
│   ├─ [X19 - 0x108] : arg2 (X2)  
│   ├─ [X19 - 0x100] : arg3 (X3)  
│   └─ [X19 - 0xF8]  : arg4 (X20/v6)  
│  
└─ [X19 - 0x138] = X21 → 虚拟寄存器堆 (32 * 8 = 256字节)  
    └─ [X21 + 0x00] : PC指针 (当前执行位置)  
  
低地址  
  
读内存操作模拟  
; 示例：LDR rd, [rs + imm]  (opcode 0xF系列)  
loc_2D84:  
    ADD X9, X9, W11, SXTH          ; 地址 = R[rs] + sign_extend(imm16)  
    ; 根据子opcode选择加载大小：  
      
loc_3290:  ; LDR W (32位)  
    LDR W9, [X9]                   ; 从计算地址加载32位  
  
写内存操作模拟  
; 示例：STR rs, [rb + imm]  (opcode 0x14系列)  
loc_2E94:  
    ADD X9, X9, W11, SXTH          ; 地址 = R[rb] + sign_extend(imm16)  
      
loc_3388:  ; STR X (64位)  
    LDR X8, [X8, [#8](javascript:;)]               ; 从R[rs]读取值  
    STR X8, [X9]                   ; 存储到内存`
```

3、外部函数调用模拟

```
`; === 函数初始化 ===  
0x2C34: LDP X20, X19, [X4]         ; X20 = 回调函数指针  
                                    ; X19 = VM上下文指针  
0x2C68: STR X20, [X19, #-0xF8]     ; 保存函数指针  
  
; === 准备调用 (PC到达终点或遇到特殊指令) ===  
loc_3C18:  
    LDR X0, [X4]                   ; 恢复参数1  
    LDR X1, [X5]                   ; 恢复参数2  
    MOV X24, X4                    ; 保存X4  
    MOV X22, X5                    ; 保存X5  
    BLR X20                        ; 调用外部函数 ← 关键！  
      
; === 调用返回处理 ===  
    LDUR X0, [X19, #-0x10]         ; 恢复返回地址  
    MOV X5, X22                    ; 恢复寄存器  
    MOV X4, X24  
    STR X0, [X21]                  ; 更新PC  
    CBNZ X0, loc_2CC4              ; 继续执行VM`
```

vm 内存模型总结

```
`┌─────────────────────────────────────────┐  
│  宿主机物理内存 (ARM64 真实内存)        │  
│                                         │  
│  ┌───────────────────────────────────┐ │  
│  │ VM运行时栈帧 (基址=X19)          │ │  
│  │                                   │ │  
│  │  [高地址]                         │ │  
│  │  ...                             │ │  
│  │  [X19-0x08]  code_base           │ │ ← 虚拟指令段基址  
│  │  [X19-0x10]  return_addr         │ │  
│  │  [X19-0x20]  vm_state            │ │  
│  │  [X19-0x30]  LO寄存器            │ │  
│  │  [X19-0x100] args[0..3]          │ │  
│  │  [X19-0x138] → X21 (寄存器堆)    │ │  
│  │  [低地址]                         │ │  
│  └───────────────────────────────────┘ │  
│                                         │  
│  ┌───────────────────────────────────┐ │  
│  │ 虚拟寄存器堆 (基址=X21)          │ │  
│  │  [X21+0x00]  PC                  │ │ ← 虚拟PC指针  
│  │  [X21+0x08]  R0                  │ │ ← 32个虚拟寄存器  
│  │  [X21+0x10]  R1                  │ │  
│  │  ...                             │ │  
│  │  [X21+0xF8]  R31                 │ │  
│  └───────────────────────────────────┘ │  
│                                         │  
│  ┌───────────────────────────────────┐ │  
│  │ 虚拟指令段 (通过R[base]访问)     │ │ ← VM bytecode  
│  └───────────────────────────────────┘ │  
│                                         │  
│  ┌───────────────────────────────────┐ │  
│  │ 虚拟数据段 (通过R[base]访问)     │ │ ← VM data  
│  └───────────────────────────────────┘ │  
└─────────────────────────────────────────┘`
```

**三、再以一个 handler 为例子分析**  
以 opcode=0x2 的 hanler 为分析例子

```
`AND             W11, W12, [#0xF000](javascript:;)  
UBFX            W10, W12, [#6](javascript:;), [#6](javascript:;)  
BFXIL           W11, W18, [#0x14](javascript:;), [#0xC](javascript:;)  
ORR             W10, W11, W10  
ADD             X12, X21, [#8](javascript:;) ; 知道x21是虚拟寄存器基地址很重要  
ORR             W10, W10, W17,LSR[#20](javascript:;)  
ORR             W10, W10, W16,LSR[#20](javascript:;)  
LDR             X9, [X12,W9,UXTW[#3](javascript:;)] ; 取寄存器  
ORR             W10, W10, W15,LSR[#20](javascript:;)  
ORR             W10, W10, W14,LSR[#20](javascript:;)  
ORR             W10, W10, W13,LSR[#20](javascript:;) ; 取立即数  
CMP             X9, W10,SXTH ; 比较，这个相当于真实执行的动作  
CSET            W9, LT  
STR             X9, [X12,W8,UXTW[#3](javascript:;)] ; 写结果回寄存器`
```

**四、最后再以一个实际的指令分析**  
分析指令：0x23BF0217  
第一步：指令格式解析

```
`指令：0x23BF0217  
二进制：0010 0011 1011 1111 0000 0010 0001 0111  
  
字段解析（从低位到高位）：  
[5:0]   = 0x17 (23) → opcode（操作码）  
[10:6]  = 0x00      → 字段1  
[15:11] = 0x04      → 字段2    
[20:16] = 0x1F      → r2 (源寄存器2)  
[25:21] = 0x1D      → r1 (源寄存器1)  
[26]    = 1         → bit26  
[27]    = 1         → bit27  
[28]    = 0         → bit28  
[29]    = 1         → bit29  
[30]    = 0         → bit30  
[31]    = 0         → bit31`
```

第二步：取指过程（Fetch）

```
`loc_2CC8:  
    LDR W12, [X0]    ; ← 从 X0（虚拟指令指针）读取 32 位指令到 W12  
                      ; W12 = 0x23BF0217`
```

第三步：指令解码（Decode）

```
`; 提取 opcode（低 6 位）  
0x2CD4: AND W10, W12, [#0x3F](javascript:;)     ; W10 = 0x17 (opcode = 23)  
  
; 提取寄存器字段  
0x2D24: UBFX W9, W12, [#0x15](javascript:;), [#5](javascript:;)  ; W9 = bits[25:21] = 0x1D (r1)  
0x2D28: UBFX W8, W12, [#0x10](javascript:;), [#5](javascript:;)  ; W8 = bits[20:16] = 0x1F (r2)  
  
; 提取立即数字段（bits 26-31, 12-15, 6-10）  
0x2CEC-0x2D38: 组合多个位段形成立即数  
    bit28 → W16 = 0  
    bit29 → W15 = 0x20000000    
    bit30 → W14 = 0  
    bit31 → W13 = 0  
    bits[26-27] → 组合到 W11  
    ...  
    最终立即数 → W11  
关键解码字段：  
  
r1 = 29 (0x1D) - 第一个源寄存器索引  
r2 = 31 (0x1F) - 第二个源寄存器索引  
opcode = 23 (0x17) - 操作码`
```

第四步：操作数获取（Operand Fetch）

```
`根据 opcode 23 (0x17)，会跳转到 loc_2D40 进行处理：  
  
loc_2D40:  ; case 0x17 处理  
    ; 计算虚拟寄存器地址  
    ADD X9, X21, W9, UXTW[#3](javascript:;)   ; X9 = &vReg[29]  
    ADD X8, X21, W8, UXTW[#3](javascript:;)   ; X8 = &vReg[31]  
      
    ; 读取操作数  
    LDR X9, [X9, [#8](javascript:;)]          ; 操作数1 = vReg[29]  
    LDR X8, [X8, [#8](javascript:;)]          ; 操作数2 = vReg[31]`
```

第五步：指令执行（Execute）

```
`loc_3388:  ; 实际执行（在 case 0x17 的处理路径中）  
    ; 将 vReg[r1] 的值存储到 vReg[r2] 指向的内存地址  
    STR X8, [X9]              ; *vReg[29] = vReg[31]`
```

第六步：指令指针更新

```
`loc_3A78:  
    ADD X0, X0, [#4](javascript:;)            ; vIP += 4 (指向下一条指令)  
    STR X0, [X21]             ; 保存更新后的 vIP`
```

完整执行流程：

```
`┌──────────────────────────────────────────┐  
│  1. 取指 (Fetch) @ 0x2CC8               │  
│     LDR W12, [X0]                        │  
│     → W12 = 0x23BF0217                   │  
└────────────┬─────────────────────────────┘  
             │  
             ↓  
┌──────────────────────────────────────────┐  
│  2. 解码 (Decode) @ 0x2CD4-0x2D38       │  
│     - opcode = 0x17                      │  
│     - r1 = 29 (vReg[29])                 │  
│     - r2 = 31 (vReg[31])                 │  
└────────────┬─────────────────────────────┘  
             │  
             ↓  
┌──────────────────────────────────────────┐  
│  3. 取操作数 (Operand) @ loc_2D40       │  
│     X9 = vReg[29]  (源数据)             │  
│     X8 = vReg[31]  (目标地址)           │  
└────────────┬─────────────────────────────┘  
             │  
             ↓  
┌──────────────────────────────────────────┐  
│  4. 执行 (Execute) @ loc_3388            │  
│     STR X9, [X8]                         │  
│     *(vReg[31]) = vReg[29]               │  
└────────────┬─────────────────────────────┘  
             │  
             ↓  
┌──────────────────────────────────────────┐  
│  5. 更新 vIP @ loc_3A78                  │  
│     vIP += 4                             │  
└──────────────────────────────────────────┘`
```

最后，我不确定是否 AI 的训练数据中是否已经包含了此样本的学习，使用其它样本能够也能分析清楚。